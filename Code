// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title FunJackpot
 * @dev A fun solo jackpot game with fake rewards - no real money involved!
 */
contract FunJackpot {
    
    struct Player {
        uint256 spins;
        uint256 biggestWin;
        uint256 totalWinnings;
        uint256 lastSpinTime;
        string lastResult;
    }
    
    mapping(address => Player) public players;
    
    string[] private outcomes = [
        "🍒 Cherry",
        "🍋 Lemon", 
        "🍊 Orange",
        "🍇 Grape",
        "🔔 Bell",
        "⭐ Star",
        "💎 Diamond",
        "🎰 JACKPOT"
    ];
    
    event SpinResult(
        address indexed player,
        string symbol1,
        string symbol2,
        string symbol3,
        string result,
        uint256 fakeReward
    );
    
    event NewHighScore(address indexed player, uint256 biggestWin);
    
    /**
     * @dev Spin the jackpot reels!
     */
    function spin() external returns (
        string memory symbol1,
        string memory symbol2,
        string memory symbol3,
        string memory result,
        uint256 fakeReward
    ) {
        Player storage player = players[msg.sender];
        
        // Generate three random symbols
        uint256 random1 = _random(0) % outcomes.length;
        uint256 random2 = _random(1) % outcomes.length;
        uint256 random3 = _random(2) % outcomes.length;
        
        symbol1 = outcomes[random1];
        symbol2 = outcomes[random2];
        symbol3 = outcomes[random3];
        
        // Determine result and fake reward
        if (random1 == random2 && random2 == random3) {
            // Three matching symbols!
            if (random1 == 7) {
                // Triple JACKPOT
                result = "🎉 MEGA JACKPOT! 🎉";
                fakeReward = 1000000;
            } else if (random1 == 6) {
                // Triple Diamond
                result = "💎 DIAMOND JACKPOT! 💎";
                fakeReward = 500000;
            } else if (random1 >= 4) {
                // Triple Star or Bell
                result = "⭐ BIG WIN! ⭐";
                fakeReward = 100000;
            } else {
                // Triple fruit
                result = "🎊 NICE WIN! 🎊";
                fakeReward = 50000;
            }
        } else if (random1 == random2 || random2 == random3 || random1 == random3) {
            // Two matching symbols
            result = "✨ Small Win! ✨";
            fakeReward = 10000;
        } else {
            // No match
            result = "Try Again!";
            fakeReward = 0;
        }
        
        // Update player stats
        player.spins++;
        player.lastSpinTime = block.timestamp;
        player.lastResult = result;
        
        if (fakeReward > 0) {
            player.totalWinnings += fakeReward;
            
            if (fakeReward > player.biggestWin) {
                player.biggestWin = fakeReward;
                emit NewHighScore(msg.sender, fakeReward);
            }
        }
        
        emit SpinResult(msg.sender, symbol1, symbol2, symbol3, result, fakeReward);
        
        return (symbol1, symbol2, symbol3, result, fakeReward);
    }
    
    /**
     * @dev Get player statistics
     */
    function getMyStats() external view returns (
        uint256 totalSpins,
        uint256 biggestWin,
        uint256 totalWinnings,
        string memory lastResult
    ) {
        Player memory player = players[msg.sender];
        return (
            player.spins,
            player.biggestWin,
            player.totalWinnings,
            player.lastResult
        );
    }
    
    /**
     * @dev Get leaderboard (top 10 players by biggest win)
     * Note: This is a simple implementation. For production, use off-chain indexing.
     */
    function getPlayerInfo(address playerAddress) external view returns (
        uint256 totalSpins,
        uint256 biggestWin,
        uint256 totalWinnings
    ) {
        Player memory player = players[playerAddress];
        return (
            player.spins,
            player.biggestWin,
            player.totalWinnings
        );
    }
    
    /**
     * @dev Check if player has played before
     */
    function hasPlayed(address playerAddress) external view returns (bool) {
        return players[playerAddress].spins > 0;
    }
    
    /**
     * @dev Get time since last spin
     */
    function getTimeSinceLastSpin() external view returns (uint256) {
        if (players[msg.sender].lastSpinTime == 0) {
            return 0;
        }
        return block.timestamp - players[msg.sender].lastSpinTime;
    }
    
    /**
     * @dev Internal random number generator
     */
    function _random(uint256 seed) private view returns (uint256) {
        return uint256(keccak256(abi.encodePacked(
            block.timestamp,
            block.prevrandao,
            msg.sender,
            seed,
            players[msg.sender].spins
        )));
    }
    
    /**
     * @dev Get all possible outcomes
     */
    function getOutcomes() external view returns (string[] memory) {
        return outcomes;
    }
}
